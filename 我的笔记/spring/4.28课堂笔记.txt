重点：作用域   难点：Aop
###回顾
	maven之后就不用一个一个导包了~
	IOC底层地实现和思想  自己去了解
	通过id获取bean 兼容类型（假如B继承了A 那么B也是可以获取的兼容类型）
	
#singlton
*区分好 单例的bean和单例的类
	9：16左右  如何编写代码 检验bean的创建时机？
	这也是昨天 用构造器创建bean 的时候set方法也执行的原因
#prototype 原型的/多例的
	单例的在创建IOC容器对象时 就创建bean的对象  每次getbean 都是这一个对象
	多例的 在创建IOC容器对象是 不创建bean的对象  每次getbean 都创建一个新的bean
#request 和 session

#生命周期
	① 通过构造器或工厂方法创建bean实例。。。这个不太清楚  是配置bean的两种方式吗？
	初始化和销毁方法 自己处理的  car类中 自己写的 初始化和销毁方法体是啥？  
	
	
 *bean的后置处理器
	导源码包之后 一些实现类的具体参数 会具体化
	
	后置处理可以进行校验  或者具体的业务
	配置后置处理器  后置处理器 是单独的一个类


##2.9 引用外部属性文件
	有两种方式    原理相同   doc文档显示的是第二种  第一种看视频
	3.指定properties属性文件的位置  location="classpath: spring特有的属性
					location="classpath:*   有子项目的情况

	有个小插曲  就是外部属性文件中的字段前面需要有前缀 jdbc 否则读不到配置文件中的信息 而回拿到windows系统中的信息


#2.10 自动装配
	装配 就是给属性赋值把？
	前面学得都是手动装配  
aotuwire=“byName”   从成员变量的名称（属性名） 去配置文件中找对应的bean  匹配id
aotuwire=“byType”   匹配class

*这个自动装配好不好？从使用的角度
较差 
1.所有对象属性都会进行装配  灵活性差  
2.要么byname  要么 byType   只能选择一种  灵活性差
所以用下面这个 通过注解装配bean 

10*2.11 通过注解配置bean

分层 目的是为了 解耦  通过  接口  做开发时  controllor 没有接口 因为和视图相关 dao和service都有接口

11：20 前后 注解配置 的 配置文件走神了  
 报错  -  需要导AOP包
  配置 和前面那个范畴是并列的？

autowire是 通过byname 还是bytype方式？   



###下午
如何实现 能装配就装配  装配不了就不装配  required=false

	 以前都是往set方法上加注释 自动装配  现在可以往成员变量上加  并且推荐这种做法
			




##AOP

15#在讲AOP之前 先解决日志的问题
	先没有加圈3的需求
	
硬编码  没有设计的内容在里面    日志功能和业务功能耦合在一起   


#*！动态代理
	代理设计模式
	
【学习中的概念】
	
17#原理

JDK动态代理  
1.proxy类：是所有动态代理类的父类  专门用于生成代理类或者是代理对象
	getProxyClass ：用来生成代理类的Class对象
	newProxyInstance：：用于生成代理对象
2.InvocationHandler  ：（接口）完成动态代理的整个过程
	invoke 方法  【！！！代理对象调用代理方法，会回来调用InvocationHandler的invoke方法；】整个动态代理的过程体 写在invoke里面   
	*和反射中的invoke方法 不是一回事


#20   目标对象  如何获取代理  代理要做什么

	*目标对象  是计算器对象

[老师的代码中]动态代理的底层  $proxy00  是动态代理类的class文件反编译过来的


web提示-安哥拉js